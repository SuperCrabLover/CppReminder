# **Моя памятка по C++**

Если ты это читаешь - значит пришло время писать код на плюсах. В данный момент я тоже не помню как это делать, но у меня (в отличие от тебя) есть время вспомнить, поэтому тут будут находиться все штуки, которые ты наверняка забыл, глупая голова. Также в данном документе я укажу сокровенные знания с поясов по плюсам, короче должно получиться хорошо, надеюсь, я это всё не забросил.

## С чем я столкнулся с самого начала

- Компилирование со всеми прибамбасами:

  ```bash
  g++ -pedantic -Wall -Wextra -Wcast-align -Wcast-qual -Wctor-dtor-privacy -Wdisabled-optimization -Wformat=2 -Winit-self -Wlogical-op -Wmissing-declarations -Wmissing-include-dirs -Wnoexcept -Wold-style-cast -Woverloaded-virtual -Wredundant-decls -Wshadow -Wsign-promo -Wstrict-null-sentinel -Wstrict-overflow=5 -Wswitch-default -Wundef -Werror -Wno-unused test.cpp  -g -o a
  ```

- Библиотека ввода-вывода `#include <iostream>`, а не `#include <stdio.h>`, хотя и она тоже

- Строки это `std::string`, лежат в `#include <string>`

- Итерация по всем элементам вектора может выглядеть вот так:

  ```c++
  for (auto current_elem_name : vector_name)
  {
      std::cout << _current_elem_name << " ";
  }
  ```

- Чтобы создать вектор, содержимое которого известно заранее, используются фигурные скобки:

  ```C++
  std::vector<int> days_in_month = {31, 28, 31, 30, 31};
  ```

  

## Первая неделя Белого Пояса

1. `std::cin >> a >> b >> c;` работает именно так как, тебе хочется.

2. Перебрать слово по буквам можно с помощью `str_prot.at(i)`, где `i` - индекс буквы в слове `str_prot`. Метод вернет букву, разумеется. <!--Миллениалы изобрели разыменование по индексу а-ля str_prot[i]-->. Вывод - <u>с</u><u>троки всё ещё массив чаров</u>, как и в Си.

3. Чтобы развернуть вектор можно использовать `std::reverse` из 

   ```c++
   #include <iterator>
   #include <algorithm>
   ```

   Пример: 

   ```c++
   vector<int> a; 
   reverse(a.begin(), v.end()); 
   ```
   
   Точно так же разворачивается и строка.

## Вторая неделя Белого Пояса

### Векторы 
1. Сортируем 

   ```c++
   #include <algorithm>
   #include <vector>
   
   using namespace std;
   int main(void)
   {
       vector<int> nums = {3, 6, 1, 2, 0, 2};
       sort(begin(nums), end(nums));
       return 0;
   }
   ```

2. Константные ссылки

   Существует проблема: иногда нам хочется вызвать функцию, которая не должна менять входные параметры, но при этом ей на вход могут подаваться очень большие структуры. Если передавать параметры "традиционным" способом, то произойдет полное (глубокое) копирование структуры, что может занимать место и память. Передача параметра по ссылке частично решит нашу проблему - копироваться будет меньшее количество данных (очень малое), однако тогда функция сможет поменять исходные данные, которые были ей переданы. Чтобы полностью решить нашу проблему можно воспользоваться `const`: 

   ```c++
   void foo(const int& x)
   ```

   Теперь копироваться будет лишь адрес, однако при попытке изменить содержимое параметра программа просто не станет компилироваться!

   Также "константная ссылка" позволит написать следующий кусок кода, который не вызовет ошибок компиляции:

   ```c++
   void foo(const int& x)
   {
       ...
   }
   int bar()
   {
       ...
       return ...;
   }
   int main(void)
   {
   	foo(bar); //не сохраняем ничего в отдельную переменную, а сразу отправляем результат в foo
       return 0;
   }
   
   ```

   Если в данном сниппете убрать `const`, то программа перестанет компилироваться, так как по правилам C++ результат вызова функции не может быть передан "по ссылке" в другую функцию.

3. На самом деле, `const` это специальный модификатор типов данных, запрещающий изменение объектов. Если попытаться изменить `const` переменную, то программа не будет компилироваться. Если сделать "константный контейнер", то `const` будет распространяться и на элементы этого контейнера:

   ```c++
   ...
   int main(void)
   {
       const vector<string> w = {"hello"};
       w[0][0] = 'H'; //Из-за этой строчки программа не будет компилироваться, хотя мы просто поменяли первую букву первого элемента контейнера w
   	return 0;
   }
   ```

   

4. Как расширить вектор? Ответ: `resize`:

   ``` c++
   ...
   vector<int> a(28, 0);//Создаем вектор из 28 элементов заполненный нулями
   a.resize(31);//Теперь в векторе 31 элемент, содержимое вектора a не изменилось
   a.assign(100, 1);//А теперь вектор имеет размер 100 и весь заполнен единицами!
   ```

5. `vector_name.clear()` удаляет все элементы, после чего размер (size) `vector_name` становится равным нулю.

### Словари (map)

 Объявление:

```c++
#include <map>
map<int, string> slovar;
slovar[1950] = "sqooba";
slovar[2019] = "booba";
slovar[1950] = "Jija";
```

Перебор элементов

```c++
for (auto item : slovar)
{
    cout << item.first << " : "; //выводим ключ
    cout << item.second << ";" << endl; //значение 
}
//1950 : Jija;
//2019 : booba;
```

**Важное свойство map** - ключи в словаре автоматически **сортируются** и при выводе предложенным способом сначала напечатается ключ и значение с меньшим значением ключа (то есть $1950$).



**Размер словаря** можно получить так же как мы делали это для вектора:

```c++
cout << slovar.size() << endl; // в данном случае программа выведет 2 ("sqooba" перезатрется на "Jija")
```



**Обращение по ключу** происходит так же, как и в векторе или массиве:

```c++
cout << slovar[1950] << endl; // "Jija"
```

Однако мы можем случайно (или нет) обратиться по ключу, которого еще нет в словаре:

```
cout << slovar[12] << endl; 
```

В этом случае в словаре автоматически создаётся элемент словаря "ключ-значение" с ключом $12$ и с неким значением по умолчанию для данного типа (в нашем случае `string`, для которого значение по умолчанию есть пустое слово)



**Удаление элемента map** осуществляется с помощью метода `map_name.erase(key_name)`	



**Статическое объявление map**:

```c++
map<string, int> m  = {{"one", 1}, {"two", 2}, {"three", 3}};
```



#### Новые фичи для map 

"Свежевведенные" возможности языка. Теперь итерироваться по словарю можно удобнее:

```c++
map<string, int> m;
for (const auto& [key, value] : m)
{
	cout << key << ": " << value << endl;
}
```

### Множества (set)

Контейнер с говорящим именем. Объявление, добавление и печать:

```c++
#include <iostream>
#include <string>
#include <set>

using namespace std;
void PrintPeople(const set<string>& s); 
void PrintPeople(const set<string>& s)
{
    cout << "Size: " << s.size() << endl;
    for (auto x : s)
    {
        cout << x << endl;
    }
}

int main(void)
{
    set<string> famous_people;			  //множество строк 
    famous_people.insert("Morgenshtern"); // Добавляем известных людей
    famous_people.insert("Slava Marlow");
    famous_people.insert("Slava Marlow"); //Добавление второго Славы Марлова ничего не измени - он уже там есть
    PrintPeople(famous_people);           //Вывод: Morgenshtern \n Slava Marlow --- в алфавитном порядке
    famous_people.erase("Slava Marlow");  //Удалили Славу,теперь там только Алишер Тагирович
    return 0; 
}
```

В данном примере видно: элементы во множестве хранятся в единственном экземпляре в отсортированном порядке. Размер контейнера выводится как и прежде через `set_name.size()`. Удаление осуществляется через `set_name.erase(key)`. Посчитать количество вхождений элемента `key` в множество можно так же, как и в случае с `map`:  `set_name.count(key)` -- так как в множестве дублей не бывает, `count` может вернуть либо $1$ либо $0$. 

Объявление множество с заранее известным количеством элементов:

```c++
...
set<string> famous_people = {"Slava Marlow", "Oxxxymiron", "Morgenshtern", "Oxxxymiron"}; // оптическая иллюзия - в множестве лишь один Оксимирон
set<string> other_famous_people = {"Slava Marlow", "Oxxxymiron", "Morgenshtern"};
cout << (famous_people == other_famous_people) << endl; //Вывдет 1.
...
```

Создаем **множество по вектору**:

```c++
#include <iostream>
#include <string>
#include <vector>
#include <set>

using namespace std;
void PrintSet(const set<string>& s); 
void PrintSet(const set<string>& s)
{
    cout << "Size: " << s.size() << endl;
    for (auto x : s)
    {
        cout << x << endl;
    }
}

int main(void)
{
    vector<string> test_vector = {"a", "b", "a"};
    set<string> test_set(begin(test_vector), end(test_vector));
    PrintSet(test_set);
    return 0; 
}
/* Output:
 *Size: 2
 *a
 *b
 */

```
